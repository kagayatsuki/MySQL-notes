# MySQL优化篇

## 1.插入优化

可以使用load指令，批量插入数据，格式如下

```MySQL
LOAD DATA LOCAL INFILE '文件路径'
    INTO TABLE 表名
    FIELDS TERMINATED BY '字段分隔符'
    LINES TERMINATED BY '行分隔符'
    IGNORE number LINES
    (column1, column2, ...);
```

下面是一个具体的指令：

```MySQL
LOAD DATA INFILE 'C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Uploads\\data.txt'
    INTO TABLE experi
    FIELDS TERMINATED BY ','
    LINES TERMINATED BY '\n'
    IGNORE 1 LINES
    (id, name)
   set DUPLICATE KEY UPDATE name = VALUES(name);

```

（注意格式与用法）

为了避免麻烦，需要上传到指定目录，`SHOW VARIABLES LIKE 'secure_file_priv'`; 可以查看这个目录。

## 2.order by优化

索引是优化 `ORDER BY` 的最有效手段。数据库（如 MySQL、PostgreSQL、SQL Server 等）可以利用索引直接返回有序数据，避免额外的排序操作。

原因是如果查询的 ORDER BY 列已经被索引覆盖，数据库可以直接从索引中获取有序数据。当 ORDER BY 涉及多个列时，创建复合索引可以显著提高性能。

注意：索引的**列顺序**需要与 ORDER BY 的顺序一致，且**排序方向**（ASC 或 DESC）也要匹配

## 3.group by优化

索引是优化 GROUP BY 的关键，数据库可以利用索引的有序性直接获取分组数据，减少扫描和排序开销。索引可以加速分组，减少**全表扫描**。

复合索引优化 WHERE 和 GROUP BY：
当查询包含 WHERE 条件和 GROUP BY 时，创建复合索引覆盖条件列和分组列。例如：

```sql
SELECT customer_id,COUNT(*)FROM orders WHEREstatus='completed'GROUPBY customer_id;
```

创建复合索引：

```sql
CREATEINDEX idx_status_customer ON orders (status, customer_id);
```

索引的列顺序应为：WHERE 条件列 > GROUP BY 列 > 聚合涉及的列。

覆盖索引：
如果查询的列和 GROUP BY 列都在索引中，数据库无需访问表数据。例如：

```sql
SELECT department,COUNT(*)FROM employees GROUPBY department;
```

创建覆盖索引：

```sql
CREATEINDEX idx_dept_cover ON employees (department);
```

确保 表中的列尽量少，且都在索引中。

**注意事项**：

* 索引的顺序和 GROUP BY 列的顺序应一致，否则可能无法完全利用索引。（最左前缀法则）
* 如果 GROUP BY 涉及表达式（如 GROUP BY YEAR(order_date)），索引通常无效，需预计算。

同样的道理，limit组合group by也能够实现优化。

## 4.count优化

只需要记住一点，**COUNT(*)****通常是最快的，因为不需要检查特定列。**

如果 COUNT 查询包含 WHERE 条件，确保条件列有索引。

## 5.update优化

update优化除了设置索引意外，还涉及到锁的内容：

**UPDATE** 会锁定受影响的行或表，优化锁和事务管理可以减少并发冲突。因此我们可以使用行级锁（默认在 InnoDB 等引擎中）代替表级锁。

如果没有索引，数据库会进行全表扫描而使锁升级为表锁。

> 需要说明一下，行级锁是数据库对表中特定行施加的锁，仅锁定被操作的行，其他行仍可被其他事务访问。（高并发场景）
>
> 表级锁是对整个表施加的锁，锁定整个表，阻止其他事务对该表的任何操作。表级锁的粒度较大，适合低并发或批量操作场景。

总的来说，所有的优化以索引为中心，无脑加索引就完事了（）
